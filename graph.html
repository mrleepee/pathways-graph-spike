<!--
	THIS EXAMPLE WAS DOWNLOADED FROM https://echarts.apache.org/examples/en/editor.html?c=graph
-->
<!DOCTYPE html>
<html lang="en" style="height: 100%">
<head>
  <meta charset="utf-8">
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16'%3E%3Crect width='16' height='16' fill='%234cc'%3E%3C/rect%3E%3C/svg%3E">
  <script>
    (function () {
      var originalConsoleError = console.error && console.error.bind(console);
      window.__errorLog = [];
      function appendToOverlay(message) {
        try {
          var el = document.getElementById('error-log');
          if (!el) return;
          el.setAttribute('data-has-errors', 'true');
          var item = document.createElement('div');
          item.textContent = message;
          el.appendChild(item);
        } catch (_) {}
      }
      console.error = function () {
        var msg = Array.prototype.map.call(arguments, function (a) {
          if (a && a.stack) return a.stack;
          try { return JSON.stringify(a); } catch (_) { return String(a); }
        }).join(' ');
        window.__errorLog.push(msg);
        appendToOverlay(msg);
        if (originalConsoleError) originalConsoleError.apply(console, arguments);
      };
      window.addEventListener('error', function (e) {
        var msg = e && e.message ? e.message : String(e);
        if (e && e.error && e.error.stack) msg = e.error.stack;
        console.error('window.onerror:', msg);
      });
      window.addEventListener('unhandledrejection', function (e) {
        var msg = (e && e.reason && (e.reason.stack || e.reason.message)) ? (e.reason.stack || e.reason.message) : String(e && e.reason);
        console.error('unhandledrejection:', msg);
      });
    })();
  </script>
</head>
<body style="height: 100%; margin: 0">
  <div id="status" style="position:fixed;top:0;right:0;background:#eef;color:#222;padding:4px 6px;font:12px/1.2 monospace;z-index:99998">loading</div>
  <div id="controls" style="position:fixed;top:0;left:0;background:#eef;color:#222;padding:4px 6px;font:12px/1.2 monospace;z-index:99998">
    View:
    <a href="?view=graph">graph</a>
    |
    <a href="?view=tree">tree</a>
  </div>
  <div id="error-log" data-has-errors="false" style="position:fixed;bottom:0;left:0;right:0;max-height:30%;overflow:auto;background:rgba(0,0,0,0.8);color:#fdd;font:12px/1.4 monospace;padding:6px;z-index:99999"></div>
  <div id="container" style="height: 100%"></div>

  <script type="text/javascript" src="./echarts.min.js"></script>

  <script type="text/javascript">
    var dom = document.getElementById('container');
    var myChart = echarts.init(dom, null, { renderer: 'canvas', useDirtyRect: false });
    var params = new URLSearchParams(location.search);
    var view = (params.get('view') || 'graph').toLowerCase(); // 'graph' or 'tree'
    var dataFile = 'echarts_graph.json';
    var option;

    // --- Edge list -> ECharts converter (uses edge.label for node labels) ---
    function edgesToEcharts(edges, labelsByUri) {
      labelsByUri = labelsByUri || {};

      var seen = new Set();
      var clean = [];
      var nodesSet = new Set();
      var childrenByParent = new Map();
      var parentsByChild = new Map();
      var levelByNode = new Map();
      var categoryByNode = new Map();
      var categoriesSet = new Set();

      for (var i = 0; i < edges.length; i++) {
        var e = edges[i] || {};
        var child = e.pathwayNodeUri || e.pathway;
        var parent = e.parentNodeUri;
        var type = e.type;
        var level = e.level;
        if (!child) continue;

        if (e.label && !labelsByUri[child]) labelsByUri[child] = String(e.label).trim();

        var category = 'node';
        if (type === 'pathway') category = 'pathway';
        if (type === 'node' && parent === 'root') category = 'top level';
        categoryByNode.set(child, category);
        categoriesSet.add(category);
        if (level != null && !levelByNode.has(child)) levelByNode.set(child, level);
        nodesSet.add(child);

        if (parent && parent !== 'root') {
          if (!categoryByNode.has(parent)) categoryByNode.set(parent, 'node');
          categoriesSet.add('node');
          nodesSet.add(parent);
          if (!childrenByParent.has(parent)) childrenByParent.set(parent, new Set());
          childrenByParent.get(parent).add(child);
          if (!parentsByChild.has(child)) parentsByChild.set(child, new Set());
          parentsByChild.get(child).add(parent);

          var k = child + '|' + parent;
          if (seen.has(k)) continue;
          seen.add(k);
          clean.push({ child: String(child), parent: String(parent) });
        }
      }

      function label(uri) { return labelsByUri[uri] || uri; }

      var roots = [];
      childrenByParent.forEach(function (_kids, p) {
        if (!parentsByChild.has(p)) roots.push(p);
      });
      if (!roots.length) {
        nodesSet.forEach(function (n) {
          if (!parentsByChild.has(n)) roots.push(n);
        });
      }

      var seenTree = new Set();
      function dfs(node) {
        if (seenTree.has(node)) {
          return { name: label(node), value: node, children: [] };
        }
        seenTree.add(node);
        var kids = childrenByParent.get(node);
        var out = { name: label(node), value: node };
        out.children = kids ? Array.from(kids).map(dfs) : [];
        return out;
      }
      var forest = roots.map(dfs);

      var sizeFactor = 8; // enlarge nodes based on level (1-7 -> 8-56)
      var nodes = Array.from(nodesSet).map(function (id) {
        var lvl = levelByNode.has(id) ? levelByNode.get(id) : null;
        var node = {
          id: id,
          name: label(id),
          value: id,
          category: categoryByNode.get(id)
        };
        if (lvl != null) {
          var scaled = lvl * sizeFactor;
          node.size = scaled;
          node.symbolSize = scaled;
        }
        return node;
      });

      var idToIndex = new Map(nodes.map(function (n, i) { return [n.id, i]; }));

      var links = clean
        .filter(function (e) { return idToIndex.has(e.parent) && idToIndex.has(e.child); })
        .map(function (e) {
          var sIdx = idToIndex.get(e.parent);
          var tIdx = idToIndex.get(e.child);
          return {
            source: sIdx,
            target: tIdx,
            sourceUri: nodes[sIdx].id,
            targetUri: nodes[tIdx].id,
            sourceLabel: nodes[sIdx].name,
            targetLabel: nodes[tIdx].name
          };
        });

      var categoryOrder = ['pathway', 'node', 'top level'];
      var categories = categoryOrder.filter(function (c) { return categoriesSet.has(c); });

      return { forest: forest, nodes: nodes, links: links, categories: categories };
    }
    // ----------------------------------------------------------------------

    // Shared tooltip formatter for both graph and tree
    function makeTooltipFormatter(kind) {
      return function (p) {
        var enc = echarts.format.encodeHTML;
        if (p.dataType === 'node') {
          var n = p.data || {};
          var label = n.name != null ? String(n.name) : '';
          var uri = n.value != null ? String(n.value) : '';
          // Show visible label, then URI
          return '<b>' + enc(label) + '</b><br/>URI: ' + enc(uri);
        }
        if (p.dataType === 'edge' && kind === 'graph') {
          var d = p.data || {};
          var l1 = (d.sourceLabel != null ? d.sourceLabel : d.source) + ' → ' + (d.targetLabel != null ? d.targetLabel : d.target);
          var l2 = (d.sourceUri != null ? d.sourceUri : '') + ' → ' + (d.targetUri != null ? d.targetUri : '');
          return enc(l1) + '<br/>' + enc(l2);
        }
        return '';
      };
    }

    var statusElInit = document.getElementById('status');
    if (statusElInit) statusElInit.textContent = 'loading ' + dataFile + (view ? ' (' + view + ')' : '');
    myChart.showLoading();

    fetch(dataFile)
      .then(function (resp) {
        if (!resp.ok) throw new Error('HTTP ' + resp.status + ' ' + resp.statusText);
        return resp.json();
      })
      .then(function (graph) {
        myChart.hideLoading();

        // Detect edges-only JSON and transform if needed
        var looksLikeEdgesArray = Array.isArray(graph) && graph.length > 0
          && graph[0] && typeof graph[0] === 'object'
          && ('pathwayNodeUri' in graph[0]) && ('parentNodeUri' in graph[0]);

        var edges = null;
        var labelsByUri = (graph && (graph.labelsByUri || graph.labels)) || {};
        if (looksLikeEdgesArray) {
          edges = graph;
        } else if (graph && Array.isArray(graph.edges)) {
          edges = graph.edges;
          if (graph.labelsByUri || graph.labels) labelsByUri = graph.labelsByUri || graph.labels;
        }

        if (edges) {
          var tr = edgesToEcharts(edges, labelsByUri);

          if (view === 'tree') {
            var rootName = params.get('root');
            var treeData = rootName ? [{ name: rootName, children: tr.forest }] : tr.forest;

            option = {
              title: { text: 'Pathway Tree', subtext: dataFile, top: 'top', left: 'left' },
              tooltip: { trigger: 'item', triggerOn: 'mousemove', formatter: makeTooltipFormatter('tree') },
              series: [{
                type: 'tree',
                data: treeData,
                orient: 'LR',
                top: '2%', left: '2%', bottom: '2%', right: '20%',
                symbolSize: 6,
                expandAndCollapse: true,
                initialTreeDepth: 3,
                label: { show: true, position: 'left', align: 'right', verticalAlign: 'middle' },
                leaves: { label: { show: true, position: 'right', align: 'left' } },
                animationDuration: 800,
                animationDurationUpdate: 600
              }]
            };
            myChart.setOption(option);
            var statusEl = document.getElementById('status');
            if (statusEl) statusEl.textContent = 'ready ' + dataFile + ' (tree)';
            return;
          }

          // Replace incoming graph with transformed nodes/links/categories for the force graph
          graph = { nodes: tr.nodes, links: tr.links, categories: tr.categories };
        }

        // --- Standard ECharts graph normalization (kept, but labels come from .name we set above) ---
        var rawNodes = Array.isArray(graph.nodes) ? graph.nodes : [];
        var normalizedNodes = [];
        for (var i = 0; i < rawNodes.length; i++) {
          var rn = rawNodes[i];
          if (!rn || typeof rn !== 'object') continue;
          var nid = rn.id != null ? String(rn.id) : 'n' + i;
          var nn = {};
          for (var k in rn) { nn[k] = rn[k]; }
          nn.id = nid;
          if (nn.name == null) nn.name = String(nid);  // name = label shown on node
          if (nn.value == null) nn.value = nid;        // keep URI in value for tooltip
          if (nn.symbolSize == null) nn.symbolSize = 10;
          normalizedNodes.push(nn);
        }
        var seenIds = new Set();
        var uniqueNodes = [];
        for (var j = 0; j < normalizedNodes.length; j++) {
          var n = normalizedNodes[j];
          if (seenIds.has(n.id)) continue;
          seenIds.add(n.id);
          uniqueNodes.push(n);
        }

        // Categories (optional; levels not emphasized)
        var rawCategories = Array.isArray(graph.categories) ? graph.categories : [];
        var categoryNames = [];
        rawCategories.forEach(function (c) {
          if (typeof c === 'string' || typeof c === 'number') categoryNames.push(String(c));
          else if (c && c.name != null) categoryNames.push(String(c.name));
        });
        var categories = categoryNames.map(function (name) { return { name: String(name) }; });
        var categoryIndexByName = new Map();
        categories.forEach(function (c, i) { categoryIndexByName.set(c.name, i); });

        uniqueNodes.forEach(function (node) {
          if (typeof node.category === 'string') {
            node.category = categoryIndexByName.has(node.category) ? categoryIndexByName.get(node.category) : 0;
          } else if (typeof node.category === 'number') {
            if (node.category < 0 || node.category >= categories.length) node.category = 0;
          }
          node.label = { position: 'right', formatter: '{b}', show: true }; // ALWAYS show node label
        });

        // Normalize links to indices and also embed names/URIs for better edge tooltips
        var idToIndex = new Map(uniqueNodes.map(function (n, i) { return [n.id, i]; }));
        var normalizedLinks = [];
        var invalidCount = 0;
        if (Array.isArray(graph.links)) {
          graph.links.forEach(function (lnk) {
            var s = lnk && lnk.source;
            var t = lnk && lnk.target;
            if (typeof s === 'string') {
              if (idToIndex.has(s)) s = idToIndex.get(s);
              else if (/^\d+$/.test(s)) s = parseInt(s, 10);
            }
            if (typeof t === 'string') {
              if (idToIndex.has(t)) t = idToIndex.get(t);
              else if (/^\d+$/.test(t)) t = parseInt(t, 10);
            }
            if (typeof s === 'number' && typeof t === 'number'
                && s >= 0 && s < uniqueNodes.length && t >= 0 && t < uniqueNodes.length) {
              normalizedLinks.push({
                source: s,
                target: t,
                sourceUri: uniqueNodes[s].id,
                targetUri: uniqueNodes[t].id,
                sourceLabel: uniqueNodes[s].name,
                targetLabel: uniqueNodes[t].name
              });
            } else {
              invalidCount++;
            }
          });
        }
        if (invalidCount) console.error('invalidLinks:', invalidCount);

        var hasXY = uniqueNodes.some(function (n) { return n && n.x != null && n.y != null; });
        var layoutType = hasXY ? 'none' : 'force';

        option = {
          title: { text: 'Pathway Graph', subtext: dataFile, top: 'top', left: 'left' },
          tooltip: { trigger: 'item', formatter: makeTooltipFormatter('graph') },
          legend: categories.length ? [{ data: categories.map(function (a) { return a.name; }) }] : [],
          animationDuration: 1500,
          animationEasingUpdate: 'quinticInOut',
          series: [{
            name: 'Pathway Graph',
            type: 'graph',
            legendHoverLink: false,
            layout: layoutType,
            data: uniqueNodes,
            links: normalizedLinks,
            categories: categories,
            roam: true,
            label: { position: 'right', formatter: '{b}', show: true }, // keep labels visible
            lineStyle: { color: 'source', curveness: 0.3 },
            emphasis: { focus: 'adjacency', lineStyle: { width: 10 } },
            force: hasXY ? undefined : { repulsion: 180, edgeLength: [60, 140] },
            edgeSymbol: ['none', 'arrow']
          }]
        };

        myChart.setOption(option);
        var statusEl = document.getElementById('status');
        if (statusEl) statusEl.textContent = 'ready ' + dataFile + ' (' + view + ')';
      })
      .catch(function (err) {
        console.error('fetchError:', dataFile, String(err && err.message ? err.message : err));
        var statusEl = document.getElementById('status');
        if (statusEl) statusEl.textContent = 'error ' + dataFile;
      });

    if (option && typeof option === 'object') {
      myChart.setOption(option);
    }
    window.addEventListener('resize', myChart.resize);
  </script>
</body>
</html>